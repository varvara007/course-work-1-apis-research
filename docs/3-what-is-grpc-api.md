## Основы gRPC

gRPC (Google Remote Procedure Call) – это новый и современный фреймворк для разработки масштабируемых, современных и быстрых API и дословно переводится как система удаленного вызова процедур, разработанный компанией Google еще в  2015 году (https://developers.googleblog.com/2015/02/introducing-grpc-new-open-source-http2.html). Используется многими ведущими компаниями, такими как Google, Square и Netflix, и позволяет программистам писать микросервисы на любом языке, который они хотят, сохраняя при этом возможность легко устанавливать связь между этими сервисами. 

Почему появилась необходимость в новом подходе к проектированию API ? 

## Недостатки REST API

REST API являлся и является самым популярным подходом к проектированию API и  решал свою задачу хорошо. Однако, на маштабах пользовательской нагрузки таких крупных компаний как Yandex и Google начали всплывать некоторые его недостатки:

- Транспортная проблема: всякое взаимодействие с REST API в формате запрос-ответ требовало от клиента подключаться заново к серверу, поскольку это является ограничение HTTP 1.1. В рамках него невозможно установить долгосрочное соединение с серверов и посылать множество запросов, получая множество ответов. Это накладывает ряд издержек при сетевом взаимодействии.
- Проблема формата данных:  протокол HTTP 1.1, как уже утверждалось ранее, является текстовым и основной формат данных используемый в REST API это JSON. Он типизирован, отлично читается человеком, поскольку является текстовым. Однако, в крупных компаниях таких, как Google, где в сутки пользователи отправляют миллиарды запросов, такой формат является избыточным. Структура JSON требует явного описания полей каждого запроса и каждого ответа текстом, например, name, book_id, author и так далее. И так  миллиард раз день. 

## Протокол HTTP 2.0

Одно из ключевых отличий GRPC, это смена протокола HTTP 1.1 на HTTP 2.0. 

HTTP 2.0  полностью сохранил семантику HTTP 1.1:
   - HTTP методы (POST, GET, PUT)
   - HTTP заголовки (Host, Content-type, Authorization)
   - HTTP Body {base64(PNG), json} <---- TEXT
   
Что нового:
- Появилось мультиплексирование

```json
channel {
   CLIENT -- TEXT---> SERVER
   SERVER ---TEXT----> CLIENT
}
channel { 
  CLIENT -- TEXT---> SERVER
  SERVER ---TEXT----> CLIENT
}
```

- Появился бинарный формат данных. Заголовки и прочие семантические элементы HTTP теперь передаются в бинарном виде



## Формат данных Protobuf 

Другое ключевое отличие gRPC от REST API - это формат передаваемых данных в секции Body протокола HTTP. В отличие от JSON в нем решили остановить свой выбор на бинарном формате Protobuf, разработанный компанией Google.

Чтобы работать с бинарными данными необходимо заранее согласовать их структуру, то есть описать по какому смещению в бинарном теле сообщения находится то или иное поле. Без этого описания клиент и сервер не смогут взаимодействовать друг с другом.

Подобно OpenAPI, который описывал структуру JSON запросов и ответов, в gRPC для этих целей используют свой мета-язык, который называется Protobuf. 

Описание структуры запроса или ответа начинается с ключевого слова `message`, затем идет перечисление типов и имен полей, которое это сообщение может содержать в себе. 

На примере ранее рассмотренного в рамках REST API сервиса получения книги по ее номеру, описание запроса могло бы выглядеть следующим образом:

```protobuf
message GetBookRequest {
  int32 book_id = 1;
}
```
а описание ответа от сервера:
```protobuf
message GetBookResponse {
   int32 id = 1;
   string name = 2;
   string author = 3;
   int32 pages = 4;
   int32 issue_date = 5;
}
```

Но одного описания формата запросов и ответов недостаточно, необходимо еще каким-то образом задать список доступных методах сервера для обращения к клиенту. Другими словами, ответить на следующие вопрос - что умеет сервер ? какие запросы и ответы соответствуют какому ресурсу ? По какому HTTP Path находятся эти ресурсы ? 

Для такого описания возможностей сервера в Protobuf существует специальная секция  `service`:

```protobuf
service BooksService {
 rpc GetBook(GetBookRequest) returns (GetBookResponse) {
   option (google.api.http) = { get: "/books/{book_id}"};
 }
 rpc ListBooks(ListBooksRequest) returns (ListBooksResponse){
   option (google.api.http) = { get: "/books"};
 }
 rpc CreateBook(CreateBookRequest) returns (CreateBookResponse) {
   option (google.api.http) = { put: "/books"};
 }
}
```

Как можно видеть, это описание содержит классические HTTP пути и методы на сервере, а так же задает формат ответа и запроса для каждого из них. 

Таким образом, чтобы взаимодействовать с удаленным серверов, клиент должен получить его описание в формате protobuf и написать программу соответствующую ей.

### Автогенерация кода

Разработка и клиента и сервера, общающихся в бинарном формате, была бы крайне сложной, если бы программист вручную сам формировал тело сообщений каждый раз во время разработки программы. 

Поэтому в gRPC есть автогенерация кода для формирования бинарных сообщений на всех популярных языках программирования мира. Это делается с помощью консольной утилиты под называнием `protoc`, которая умеет принимать на вход описание структур в формате protobuf, а на выходе получать исходной код программы, формирующий тело бинарных сообщений, отправляемых и получаемых от сервера.

Пример вызова консольной утилиты:
```
protoc --python_out=/book.py  book.proto
```
Пример веб-сервиса по генерации исходного кода:

![enter image description here](https://i.ibb.co/kgGvN69/2022-12-16-19-31-48.png)
