# GraphQL

GraphQL — это один из популярных подходов к организации API сервисов на базе протокола HTTP 1.1. Он включает в себя язык запросов данных и язык манипулирования данными с открытым исходным кодом для построения веб ориентированных программных интерфейсов, то есть API. GraphQL был разработан как внутренний проект компании Facebook в 2012 году.

Какую задачу должен был решить GraphQL ?

## Разные потребности у клиентов

С ростом числа потребителей у того или иного REST API так или иначе возникает необходимость постоянного его расширения и адаптации под потребности клиентов. Одним клиентам нужен один набор полей API, другим другой, третьим и вовсе нужна композиция нескольких объектов, желательно доступным по одному endpoint. Это вынуждает разработчиков вручную пытаться все больше и больше добавлять параметров запросов, различных флагов, затем на серверной части писать код, который их обрабатывает.

В нашем примере про API библиотеки был метод получения книги по ее идентификатору:

```
GET /books/{book_id}
```
```json
{
  "id": 500,
  "name": "Мастер и Маргарита",
  "author": "Булгаков",
  "pages": 600,
  "issue_date": 1967
}
```
Можно легко себе представить необходимость поиска книги не только по ее идентификатору, но, например, по ее названию. Это вынудит разработчика изменить API и добавить возможность поиска двумя способами:

- `GET /books?id=500`
- `GET /books?name="Мастер и Маргарита"`

Затем может выяснится, что не всем клиентам такого API нужен полный набор полей описания книга. И так же легко себе представить клиентов, которым, например, не хватает более детальной информации об авторе.

Это вновь вынудит разработчика изменить свой API получения книги, добавив возможность динамически выбирать список полей и блоков:

- `GET /books?id=500&blocks=comments{user,text},author{id, name}`

```json
{
  "id": 500,
  "name": "Мастер и Маргарита",
  "author": { "id": 700,  name: "Булгаков"},
  "comments": [{"user": 555, "text": "Очень хорошая книга!"}]
  "pages": 600,
  "issue_date": 1967
}
```

И так для каждого ресурса на сервере. В конечном итоге API вместо простого параметра идентификатор книги обрастает гигантским количество фильтров, блоков и прочего, что явно усложняет его восприятие и клиентом и разработчиком серверной части.

## Язык запросов GraphQL

Разрабочики Facebook столкнулись с этой проблемой в 2012 году, когда стали разрабатывать мобильную версию приложения. Вдруг оказалось, что их существующий API сервера возвращает либо слишком много информации, либо недостаточно и эту информацию приходилось извлекать дополнительными запросами на сервер. Именно поэтому они решились на разработку GraphQL - языка запросов к серверу, позволяющим гибко, в зависимости от потребностей клиента, одним запросом извлекать из сервера нужную информацию.

Вместо десятка различных методов API для каждого ресурса по-отдельности:

- `GET /books`
- `GET /authors`
- `GET /comments`
- `GET /users`

со своими фильтрами, блоками и параметрами они пришли к идее одного единственного метода:

- `GET /graphql`

где в качестве одного единственного параметра передается некоторое выражение, начинающее с ключевого слова `query`

![enter image description here](https://i.ibb.co/MgMmbQw/2022-12-17-19-14-54.png)

В рамках этого выражение клиент сам указывает какие ресурсы ему нужны и их атрибуты. Более того, клиент может задать некий фильтр, позволяющий ему выбрать нужное множество ресурсов с определенными значениями атрибутов. Мы можем изменить пример выше, задав фильтр на валюту страны, например рубль и получить соответствующий список стран:

![enter image description here](https://i.ibb.co/QbTXbpc/2022-12-18-12-52-37.png)


 Этот язык запросов в некотором смысле очень похож на SQL, которым разработчики серверной части API пользуются для выборки данных из базы данных. 

Однако, встает вопрос о том, как клиент узнает о том, какие объекты и атрибуты представляет серверный API ?

## Схема данных в GraphQL

Подобно стандарту OpenAPI в REST API и Protobuf в gRPC, в GraphQL есть свой способ декларативно описать какие же ресурсы предоставляет сервер. Для начала нужно описать схему или другими словами структуру объектов. Это делается с помощью ключевого слова `type`. 

В нашем примере с библиотекой, схема книги и ее автора в GraphQL могла бы выглядеть следующим образом:

```graphql
type Book{
  id: Int
  name: String
  author: Author
  pages: Int
  issue_date: Int
}

type Author{
  id: Int,
  name: String
}
```

Однако просто описания схемы недостаточно. В GraphQL есть специальный корневой тип под названием `Query`,  которой является точкой входа в нашу схему и задает интерфейс того, к каким объектам и как можно получить доступ.

```graphql
type Query{
    books(id: Int): [Book]
    author(id: Int): [Author]
}
```

Аналогом этой схемы, но уже в REST API было бы описание двух ресурсов:

- `/books/{id}`
- `/authors/{id}`
 
Но благодаря встроенным возможностям языка запросов GraphQL, клиент мог бы самостоятельно выбирать только те данные, которые ему нужны. 
